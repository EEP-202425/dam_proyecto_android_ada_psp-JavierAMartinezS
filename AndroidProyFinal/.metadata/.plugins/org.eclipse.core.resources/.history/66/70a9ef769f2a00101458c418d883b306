package adapspand.proyfinal.ruta;

import java.util.ArrayList;
import java.util.List;

import adapspand.proyfinal.billete.Billete;
import adapspand.proyfinal.linea.Linea;
import adapspand.proyfinal.parada.Estaciones;
import adapspand.proyfinal.parada.Parada;
import adapspand.proyfinal.tren.Tren;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;

@Entity
@Table(name = "ruta")
public class Ruta {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	
	@ManyToOne
    @JoinColumn(name = "origenId")
	private Parada origen;
	
	@ManyToOne
    @JoinColumn(name = "destino_id")
	private Parada destino;
	
	@ManyToOne
	@JoinColumn(name = "RecorridoId")
	private List<Parada> recorrido;
	
	@ManyToMany
	@JoinTable(
		    name = "LineasEnRuta",
		    joinColumns = @JoinColumn(name = "rutaIdEnLinea"),
		    inverseJoinColumns = @JoinColumn(name = "lineaIdEnRuta")
		)
	private List<Linea> lineasUsadas = new ArrayList<>();
	
	private boolean transbordo = false;
	
	@OneToMany(mappedBy = "rutaCorrespondiente")
	private List<Tren> trenes = new ArrayList<>();
	
	@OneToOne(mappedBy = "billete", cascade = CascadeType.ALL)
	private Billete billete;

	public Ruta() {
		super();
	}

	public Ruta(Long id, Parada origen, Parada destino, List<Parada> recorrido) {
		super();
		this.id = id;
		this.origen = origen;
		this.destino = destino;
		this.recorrido = recorrido;
	}
	
	public Ruta getRuta(Parada origen, Parada destino) {
	    this.origen = origen;
	    this.destino = destino;

	    List<List<Estaciones>> todasLasLineas = List.of(
	        Linea.setLineaA(),
	        Linea.setLineaB(),
	        Linea.setLineaC(),
	        Linea.setLineaD(),
	        Linea.setLineaE()
	    );

	    List<Parada> mejorRuta = new ArrayList<>();
	    int minParadas = Integer.MAX_VALUE;

	    for (List<Estaciones> linea : todasLasLineas) {
	        int i = linea.indexOf(origen.getNombre());
	        int j = linea.indexOf(destino.getNombre());
	        if (i != -1 && j != -1) {
	            List<Parada> rutaActual = new ArrayList<>();
	            if (i < j) {
	                for (int k = i; k <= j; k++) {
	                    Parada p = new Parada(linea.get(k));
	                    rutaActual.add(p);
	                }
	            } else {
	                for (int k = i; k >= j; k--) {
	                    Parada p = new Parada(linea.get(k));
	                    rutaActual.add(p);
	                }
	            }

	            if (rutaActual.size() < minParadas) {
	                mejorRuta = rutaActual;
	                minParadas = rutaActual.size();
	                this.transbordo = false;
	            }
	        }
	    }

	    // Si no se encontró una ruta directa, probar combinaciones entre líneas
	    if (mejorRuta.isEmpty()) {
	        for (List<Estaciones> linea1 : todasLasLineas) {
	            for (List<Estaciones> linea2 : todasLasLineas) {
	                if (linea1 == linea2) continue;

	                for (Estaciones interseccion : linea1) {
	                    if (linea2.contains(interseccion)) {
	                        int i = linea1.indexOf(origen.getNombre());
	                        int m = linea1.indexOf(interseccion);
	                        int n = linea2.indexOf(interseccion);
	                        int j = linea2.indexOf(destino.getNombre());

	                        if (i != -1 && j != -1 && m != -1 && n != -1) {
	                            List<Parada> rutaActual = new ArrayList<>();

	                            if (i < m) {
	                                for (int a = i; a <= m; a++) {
	                                    Parada p = new Parada(linea1.get(a));
	                                    rutaActual.add(p);
	                                }
	                            } else {
	                                for (int a = i; a >= m; a--) {
	                                    Parada p = new Parada(linea1.get(a));
	                                    rutaActual.add(p);
	                                }
	                            }

	                            if (n < j) {
	                                for (int b = n + 1; b <= j; b++) {
	                                    Parada p = new Parada(linea2.get(b));
	                                    rutaActual.add(p);
	                                }
	                            } else {
	                                for (int b = n - 1; b >= j; b--) {
	                                    Parada p = new Parada(linea2.get(b));
	                                    rutaActual.add(p);
	                                }
	                            }

	                            if (rutaActual.size() < minParadas) {
	                                mejorRuta = rutaActual;
	                                minParadas = rutaActual.size();
	                                this.transbordo = true;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    // Marcar origen, destino e intermedio si hay transbordo
	    if (!mejorRuta.isEmpty()) {
	        mejorRuta.get(0).setEsOrigen(true);
	        mejorRuta.get(mejorRuta.size() - 1).setEsDestino(true);
	        if (this.transbordo) {
	            for (int i = 1; i < mejorRuta.size() - 1; i++) {
	                mejorRuta.get(i).setEsIntermedio(true);
	            }
	        }
	    }

	    this.recorrido = mejorRuta;
	    return this;
	}

	
}
